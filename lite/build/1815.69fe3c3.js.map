{"version":3,"file":"1815.69fe3c3.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/server-extension/lib/index.js"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { PageConfig } from '@jupyterlab/coreutils';\nimport { BroadcastChannelWrapper, Contents, IContents, IBroadcastChannelWrapper, } from '@jupyterlite/contents';\nimport { IKernels, Kernels, IKernelSpecs, KernelSpecs } from '@jupyterlite/kernel';\nimport { ILicenses, Licenses } from '@jupyterlite/licenses';\nimport { IServiceWorkerManager, ServiceWorkerManager, } from '@jupyterlite/server';\nimport { ISessions, Sessions } from '@jupyterlite/session';\nimport { ISettings, Settings } from '@jupyterlite/settings';\nimport { ITranslation, Translation } from '@jupyterlite/translation';\nimport { ILocalForage, ensureMemoryStorage } from '@jupyterlite/localforage';\nimport localforage from 'localforage';\n/**\n * The localforage plugin\n */\nconst localforagePlugin = {\n    id: '@jupyterlite/server-extension:localforage',\n    autoStart: true,\n    provides: ILocalForage,\n    activate: (app) => {\n        return { localforage };\n    },\n};\n/**\n * The volatile localforage memory plugin\n */\nconst localforageMemoryPlugin = {\n    id: '@jupyterlite/server-extension:localforage-memory-storage',\n    autoStart: true,\n    requires: [ILocalForage],\n    activate: async (app, forage) => {\n        if (JSON.parse(PageConfig.getOption('enableMemoryStorage') || 'false')) {\n            console.warn('Memory storage fallback enabled: contents and settings may not be saved');\n            await ensureMemoryStorage(forage.localforage);\n        }\n    },\n};\n/**\n * The contents service plugin.\n */\nconst contentsPlugin = {\n    id: '@jupyterlite/server-extension:contents',\n    requires: [ILocalForage],\n    autoStart: true,\n    provides: IContents,\n    activate: (app, forage) => {\n        const storageName = PageConfig.getOption('contentsStorageName');\n        const storageDrivers = JSON.parse(PageConfig.getOption('contentsStorageDrivers') || 'null');\n        const { localforage } = forage;\n        const contents = new Contents({\n            storageName,\n            storageDrivers,\n            localforage,\n        });\n        app.started.then(() => contents.initialize().catch(console.warn));\n        return contents;\n    },\n};\n/**\n * A plugin providing the routes for the contents service.\n */\nconst contentsRoutesPlugin = {\n    id: '@jupyterlite/server-extension:contents-routes',\n    autoStart: true,\n    requires: [IContents],\n    activate: (app, contents) => {\n        // GET /api/contents/{path}/checkpoints - Get a list of checkpoints for a file\n        app.router.get('/api/contents/(.+)/checkpoints', async (req, filename) => {\n            const res = await contents.listCheckpoints(filename);\n            return new Response(JSON.stringify(res));\n        });\n        // POST /api/contents/{path}/checkpoints/{checkpoint_id} - Restore a file to a particular checkpointed state\n        app.router.post('/api/contents/(.+)/checkpoints/(.*)', async (req, filename, checkpoint) => {\n            const res = await contents.restoreCheckpoint(filename, checkpoint);\n            return new Response(JSON.stringify(res), { status: 204 });\n        });\n        // POST /api/contents/{path}/checkpoints - Create a new checkpoint for a file\n        app.router.post('/api/contents/(.+)/checkpoints', async (req, filename) => {\n            const res = await contents.createCheckpoint(filename);\n            return new Response(JSON.stringify(res), { status: 201 });\n        });\n        // DELETE /api/contents/{path}/checkpoints/{checkpoint_id} - Delete a checkpoint\n        app.router.delete('/api/contents/(.+)/checkpoints/(.*)', async (req, filename, checkpoint) => {\n            const res = await contents.deleteCheckpoint(filename, checkpoint);\n            return new Response(JSON.stringify(res), { status: 204 });\n        });\n        // GET /api/contents/{path} - Get contents of file or directory\n        app.router.get('/api/contents(.*)', async (req, filename) => {\n            var _a;\n            const options = {\n                content: ((_a = req.query) === null || _a === void 0 ? void 0 : _a.content) === '1',\n            };\n            const nb = await contents.get(filename, options);\n            if (!nb) {\n                return new Response(null, { status: 404 });\n            }\n            return new Response(JSON.stringify(nb));\n        });\n        // POST /api/contents/{path} - Create a new file in the specified path\n        app.router.post('/api/contents(.*)', async (req, path) => {\n            const options = req.body;\n            const copyFrom = options === null || options === void 0 ? void 0 : options.copy_from;\n            let file;\n            if (copyFrom) {\n                file = await contents.copy(copyFrom, path);\n            }\n            else {\n                file = await contents.newUntitled(options);\n            }\n            if (!file) {\n                return new Response(null, { status: 400 });\n            }\n            return new Response(JSON.stringify(file), { status: 201 });\n        });\n        // PATCH /api/contents/{path} - Rename a file or directory without re-uploading content\n        app.router.patch('/api/contents(.*)', async (req, filename) => {\n            var _a, _b;\n            const newPath = (_b = (_a = req.body) === null || _a === void 0 ? void 0 : _a.path) !== null && _b !== void 0 ? _b : '';\n            filename = filename[0] === '/' ? filename.slice(1) : filename;\n            const nb = await contents.rename(filename, newPath);\n            return new Response(JSON.stringify(nb));\n        });\n        // PUT /api/contents/{path} - Save or upload a file\n        app.router.put('/api/contents/(.+)', async (req, filename) => {\n            const body = req.body;\n            const nb = await contents.save(filename, body);\n            return new Response(JSON.stringify(nb));\n        });\n        // DELETE /api/contents/{path} - Delete a file in the given path\n        app.router.delete('/api/contents/(.+)', async (req, filename) => {\n            await contents.delete(filename);\n            return new Response(null, { status: 204 });\n        });\n    },\n};\n/**\n * A plugin installing the service worker.\n */\nconst serviceWorkerPlugin = {\n    id: '@jupyterlite/server-extension:service-worker',\n    autoStart: true,\n    provides: IServiceWorkerManager,\n    activate: (app) => {\n        return new ServiceWorkerManager();\n    },\n};\n/**\n * A plugin for handling communication with the Emscpriten file system.\n */\nconst emscriptenFileSystemPlugin = {\n    id: '@jupyterlite/server-extension:emscripten-filesystem',\n    autoStart: true,\n    optional: [IServiceWorkerManager],\n    provides: IBroadcastChannelWrapper,\n    activate: (app, serviceWorkerRegistrationWrapper) => {\n        const { contents } = app.serviceManager;\n        const broadcaster = new BroadcastChannelWrapper({ contents });\n        const what = 'Kernel filesystem and JupyterLite contents';\n        function logStatus(msg, err) {\n            if (err) {\n                console.warn(err);\n            }\n            if (msg) {\n                console.warn(msg);\n            }\n            if (err || msg) {\n                console.warn(`${what} will NOT be synced`);\n            }\n            else {\n                // eslint-disable-next-line no-console\n                console.info(`${what} will be synced`);\n            }\n        }\n        if (!serviceWorkerRegistrationWrapper) {\n            logStatus('JupyterLite ServiceWorker not available');\n        }\n        else {\n            serviceWorkerRegistrationWrapper.ready\n                .then(() => {\n                broadcaster.enable();\n                logStatus();\n            })\n                .catch((err) => {\n                logStatus('JupyterLite ServiceWorker failed to become available', err);\n            });\n        }\n        return broadcaster;\n    },\n};\n/**\n * The kernels service plugin.\n */\nconst kernelsPlugin = {\n    id: '@jupyterlite/server-extension:kernels',\n    autoStart: true,\n    provides: IKernels,\n    requires: [IKernelSpecs],\n    activate: (app, kernelspecs) => {\n        return new Kernels({ kernelspecs });\n    },\n};\n/**\n * A plugin providing the routes for the kernels service\n */\nconst kernelsRoutesPlugin = {\n    id: '@jupyterlite/server-extension:kernels-routes',\n    autoStart: true,\n    requires: [IKernels],\n    activate: (app, kernels) => {\n        // GET /api/kernels - List the running kernels\n        app.router.get('/api/kernels', async (req) => {\n            const res = await kernels.list();\n            return new Response(JSON.stringify(res));\n        });\n        // POST /api/kernels/{kernel_id} - Restart a kernel\n        app.router.post('/api/kernels/(.*)/restart', async (req, kernelId) => {\n            const res = await kernels.restart(kernelId);\n            return new Response(JSON.stringify(res));\n        });\n        // DELETE /api/kernels/{kernel_id} - Kill a kernel and delete the kernel id\n        app.router.delete('/api/kernels/(.*)', async (req, kernelId) => {\n            const res = await kernels.shutdown(kernelId);\n            return new Response(JSON.stringify(res), { status: 204 });\n        });\n    },\n};\n/**\n * The kernel spec service plugin.\n */\nconst kernelSpecPlugin = {\n    id: '@jupyterlite/server-extension:kernelspec',\n    autoStart: true,\n    provides: IKernelSpecs,\n    activate: (app) => {\n        return new KernelSpecs();\n    },\n};\n/**\n * A plugin providing the routes for the kernelspec service.\n */\nconst kernelSpecRoutesPlugin = {\n    id: '@jupyterlite/server-extension:kernelspec-routes',\n    autoStart: true,\n    requires: [IKernelSpecs],\n    activate: (app, kernelspecs) => {\n        app.router.get('/api/kernelspecs', async (req) => {\n            const { specs } = kernelspecs;\n            if (!specs) {\n                return new Response(null);\n            }\n            // follow the same format as in Jupyter Server\n            const allKernelSpecs = {};\n            const allSpecs = specs.kernelspecs;\n            Object.keys(allSpecs).forEach((name) => {\n                const spec = allSpecs[name];\n                const { resources } = spec !== null && spec !== void 0 ? spec : {};\n                allKernelSpecs[name] = {\n                    name,\n                    spec,\n                    resources,\n                };\n            });\n            const res = {\n                default: specs.default,\n                kernelspecs: allKernelSpecs,\n            };\n            return new Response(JSON.stringify(res));\n        });\n    },\n};\n/**\n * The licenses service plugin\n */\nconst licensesPlugin = {\n    id: '@jupyterlite/server-extension:licenses',\n    autoStart: true,\n    provides: ILicenses,\n    activate: (app) => {\n        return new Licenses();\n    },\n};\n/**\n * A plugin providing the routes for the licenses service.\n */\nconst licensesRoutesPlugin = {\n    id: '@jupyterlite/server-extension:licenses-routes',\n    autoStart: true,\n    requires: [ILicenses],\n    activate(app, licenses) {\n        app.router.get('/api/licenses', async (req) => {\n            const res = await licenses.get();\n            return new Response(JSON.stringify(res));\n        });\n    },\n};\n/**\n * A plugin providing the routes for the lsp service.\n * TODO: provide the service in a separate plugin?\n */\nconst lspRoutesPlugin = {\n    id: '@jupyterlite/server-extension:lsp-routes',\n    autoStart: true,\n    activate: (app) => {\n        app.router.get('/lsp/status', async (req) => {\n            return new Response(JSON.stringify({ version: 2, sessions: {}, specs: {} }));\n        });\n    },\n};\n/**\n * A plugin providing the routes for the nbconvert service.\n * TODO: provide the service in a separate plugin?\n */\nconst nbconvertRoutesPlugin = {\n    id: '@jupyterlite/server-extension:nbconvert-routes',\n    autoStart: true,\n    activate: (app) => {\n        app.router.get('/api/nbconvert', async (req) => {\n            return new Response(JSON.stringify({}));\n        });\n    },\n};\n/**\n * The sessions service plugin.\n */\nconst sessionsPlugin = {\n    id: '@jupyterlite/server-extension:sessions',\n    autoStart: true,\n    provides: ISessions,\n    requires: [IKernels],\n    activate: (app, kernels) => {\n        return new Sessions({ kernels });\n    },\n};\n/**\n * A plugin providing the routes for the session service.\n */\nconst sessionsRoutesPlugin = {\n    id: '@jupyterlite/server-extension:sessions-routes',\n    autoStart: true,\n    requires: [ISessions],\n    activate: (app, sessions) => {\n        // GET /api/sessions/{session} - Get session\n        app.router.get('/api/sessions/(.+)', async (req, id) => {\n            const session = await sessions.get(id);\n            return new Response(JSON.stringify(session), { status: 200 });\n        });\n        // GET /api/sessions - List available sessions\n        app.router.get('/api/sessions', async (req) => {\n            const list = await sessions.list();\n            return new Response(JSON.stringify(list), { status: 200 });\n        });\n        // PATCH /api/sessions/{session} - This can be used to rename a session\n        app.router.patch('/api/sessions(.*)', async (req, id) => {\n            const options = req.body;\n            const session = await sessions.patch(options);\n            return new Response(JSON.stringify(session), { status: 200 });\n        });\n        // DELETE /api/sessions/{session} - Delete a session\n        app.router.delete('/api/sessions/(.+)', async (req, id) => {\n            await sessions.shutdown(id);\n            return new Response(null, { status: 204 });\n        });\n        // POST /api/sessions - Create a new session or return an existing session if a session of the same name already exists\n        app.router.post('/api/sessions', async (req) => {\n            const options = req.body;\n            const session = await sessions.startNew(options);\n            return new Response(JSON.stringify(session), { status: 201 });\n        });\n    },\n};\n/**\n * The settings service plugin.\n */\nconst settingsPlugin = {\n    id: '@jupyterlite/server-extension:settings',\n    autoStart: true,\n    requires: [ILocalForage],\n    provides: ISettings,\n    activate: (app, forage) => {\n        const storageName = PageConfig.getOption('settingsStorageName');\n        const storageDrivers = JSON.parse(PageConfig.getOption('settingsStorageDrivers') || 'null');\n        const { localforage } = forage;\n        const settings = new Settings({ storageName, storageDrivers, localforage });\n        app.started.then(() => settings.initialize().catch(console.warn));\n        return settings;\n    },\n};\n/**\n * A plugin providing the routes for the settings service.\n */\nconst settingsRoutesPlugin = {\n    id: '@jupyterlite/server-extension:settings-routes',\n    autoStart: true,\n    requires: [ISettings],\n    activate: (app, settings) => {\n        // TODO: improve the regex\n        // const pluginPattern = new RegExp(/(?:@([^/]+?)[/])?([^/]+?):(\\w+)/);\n        const pluginPattern = '/api/settings/((?:@([^/]+?)[/])?([^/]+?):([^:]+))$';\n        app.router.get(pluginPattern, async (req, pluginId) => {\n            const setting = await settings.get(pluginId);\n            return new Response(JSON.stringify(setting));\n        });\n        app.router.put(pluginPattern, async (req, pluginId) => {\n            const body = req.body;\n            const { raw } = body;\n            await settings.save(pluginId, raw);\n            return new Response(null, { status: 204 });\n        });\n        app.router.get('/api/settings', async (req) => {\n            const plugins = await settings.getAll();\n            return new Response(JSON.stringify(plugins));\n        });\n    },\n};\n/**\n * The translation service plugin.\n */\nconst translationPlugin = {\n    id: '@jupyterlite/server-extension:translation',\n    autoStart: true,\n    provides: ITranslation,\n    activate: (app) => {\n        const translation = new Translation();\n        app.router.get('/api/translations/?(.*)', async (req, locale) => {\n            if (locale === 'default') {\n                locale = 'en';\n            }\n            const data = await translation.get(locale || 'all');\n            return new Response(JSON.stringify(data));\n        });\n        return translation;\n    },\n};\n/**\n * A plugin providing the routes for the translation service.\n */\nconst translationRoutesPlugin = {\n    id: '@jupyterlite/server-extension:translation-routes',\n    autoStart: true,\n    requires: [ITranslation],\n    activate: (app, translation) => {\n        app.router.get('/api/translations/?(.*)', async (req, locale) => {\n            const data = await translation.get(locale || 'all');\n            return new Response(JSON.stringify(data));\n        });\n    },\n};\nconst plugins = [\n    contentsPlugin,\n    contentsRoutesPlugin,\n    emscriptenFileSystemPlugin,\n    kernelsPlugin,\n    kernelsRoutesPlugin,\n    kernelSpecPlugin,\n    kernelSpecRoutesPlugin,\n    licensesPlugin,\n    licensesRoutesPlugin,\n    localforageMemoryPlugin,\n    localforagePlugin,\n    lspRoutesPlugin,\n    nbconvertRoutesPlugin,\n    serviceWorkerPlugin,\n    sessionsPlugin,\n    sessionsRoutesPlugin,\n    settingsPlugin,\n    settingsRoutesPlugin,\n    translationPlugin,\n    translationRoutesPlugin,\n];\nexport default plugins;\n//# sourceMappingURL=index.js.map"],"names":["localforagePlugin","id","autoStart","provides","ILocalForage","activate","app","localforage","localforageMemoryPlugin","requires","async","forage","JSON","parse","PageConfig","getOption","console","warn","ensureMemoryStorage","contentsPlugin","IContents","storageName","storageDrivers","contents","Contents","started","then","initialize","catch","contentsRoutesPlugin","router","get","req","filename","res","listCheckpoints","Response","stringify","post","checkpoint","restoreCheckpoint","status","createCheckpoint","delete","deleteCheckpoint","_a","options","content","query","nb","path","body","copyFrom","copy_from","file","copy","newUntitled","patch","_b","newPath","slice","rename","put","save","serviceWorkerPlugin","IServiceWorkerManager","ServiceWorkerManager","optional","IBroadcastChannelWrapper","serviceWorkerRegistrationWrapper","serviceManager","broadcaster","BroadcastChannelWrapper","what","logStatus","msg","err","info","ready","enable","IKernels","IKernelSpecs","kernelspecs","Kernels","kernels","list","kernelId","restart","shutdown","KernelSpecs","specs","allKernelSpecs","allSpecs","Object","keys","forEach","name","spec","resources","default","ILicenses","Licenses","licenses","version","sessions","ISessions","Sessions","session","startNew","ISettings","settings","Settings","pluginPattern","pluginId","setting","raw","plugins","getAll","ITranslation","translation","Translation","locale","data"],"sourceRoot":""}
from collections.abc import Iterator

import numpy as np
import pytest

from skfolio.utils.tools import (
    args_names,
    bisection,
    deduplicate_names,
    default_asset_names,
    format_measure,
    input_to_array,
    safe_indexing,
    safe_split,
    validate_input_list,
)


# Generated by CodiumAI
class TestArgsNames:
    #  Returns a list of argument names for a given function.
    def test_returns_argument_names(self):
        # Define a function with arguments
        def my_function(arg1, arg2, arg3):
            pass

        # Call the args_names function
        result = args_names(my_function)

        # Check if the result is a list
        assert isinstance(result, list)

        # Check if the result contains the correct argument names
        assert result == ["arg1", "arg2", "arg3"]


class TestInputToArray:
    #  Convert a dictionary with asset names and values to a numpy array of shape (n_assets) when dim=1.
    def test_convert_dict_to_array_dim_1(self):
        items = {"asset1": 1, "asset2": 2, "asset3": 3}
        n_assets = 3
        fill_value = 0
        dim = 1
        assets_names = np.array(["asset1", "asset2", "asset3"])
        name = "items"

        expected_result = np.array([1, 2, 3])

        result = input_to_array(items, n_assets, fill_value, dim, assets_names, name)

        assert np.array_equal(result, expected_result)

    #  Raise a ValueError if items is a dictionary and assets_names is not provided.
    def test_raise_value_error_no_assets_names(self):
        items = {"asset1": 1, "asset2": 2, "asset3": 3}
        n_assets = 3
        fill_value = 0
        dim = 1
        assets_names = None
        name = "items"

        with pytest.raises(ValueError):
            input_to_array(items, n_assets, fill_value, dim, assets_names, name)


# Generated by CodiumAI
class TestFormatMeasure:
    #  Formats a positive float number without decimal places correctly.
    def test_positive_float_no_decimal(self):
        result = format_measure(10.0)
        assert result == "10.00"

    #  Formats a float number with the maximum number of decimal places correctly.
    def test_float_maximum_decimal(self):
        result = format_measure(3.141592653589793)
        assert result == "3.14"

    #  Formats a float number with the minimum number of decimal places correctly.
    def test_float_minimum_decimal(self):
        result = format_measure(0.123456)
        assert result == "0.12"


# Generated by CodiumAI
class TestBisection:
    #  The function receives a list of numpy arrays and returns an iterator.
    def test_returns_iterator(self):
        arr = [np.array([1, 2, 3]), np.array([4, 5, 6]), np.array([7, 8, 9])]
        result = bisection(arr)
        assert isinstance(result, Iterator)

    #  The function works correctly for empty arrays.
    def test_empty_arrays(self):
        arr = []
        result = list(bisection(arr))
        assert result == []

    #  The function works correctly for arrays with only one element.
    def test_single_element_array(self):
        arr = [np.array([1])]
        result = list(bisection(arr))
        assert result == []


# Generated by CodiumAI
class TestSafeIndexing:
    #  Returns the entire data if indices is None.
    def test_returns_entire_data_if_indices_is_none(self):
        X = np.array([1, 2, 3, 4, 5])
        indices = None
        result = safe_indexing(X, indices)
        assert np.array_equal(result, X)


# Generated by CodiumAI
class TestSafeSplit:
    #  Returns X_subset and y_subset when given valid inputs.
    def test_valid_inputs(self):
        # Arrange
        X = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
        y = np.array([1, 2, 3])
        indices = np.array([0, 2])
        axis = 0

        # Act
        X_subset, y_subset = safe_split(X, y, indices=indices, axis=axis)

        # Assert
        np.testing.assert_array_equal(X_subset, np.array([[1, 2, 3], [7, 8, 9]]))
        np.testing.assert_array_equal(y_subset, np.array([1, 3]))


# Generated by CodiumAI


class TestDefaultAssetNames:
    #  Returns an ndarray of str with length equal to n_assets.
    def test_returns_ndarray_with_length_equal_to_n_assets(self):
        n_assets = 5
        result = default_asset_names(n_assets)
        assert isinstance(result, np.ndarray)
        assert len(result) == n_assets

    #  Raises TypeError when n_assets is not an integer.
    def test_raises_type_error_when_n_assets_is_not_an_integer(self):
        n_assets = "5"
        with pytest.raises(TypeError):
            default_asset_names(n_assets)


def test_deduplicate_names():
    names = ["blah", "blah2", "blah3", "blah", "blah"]
    names = deduplicate_names(names)
    assert names == ["blah", "blah2", "blah3", "blah_1", "blah_2"]


# Test with valid integer inputs.
def test_int_inputs_valid():
    items = [0, 2, 4]
    n_assets = 5
    # For integer inputs, assets_names is not used.
    result = validate_input_list(items, n_assets, assets_names=None, name="test_assets")
    assert result == [0, 2, 4]


# Test with an invalid integer (out of range).
def test_int_input_invalid_index():
    items = [0, 5]  # 5 is out of range for n_assets=5 (valid indices are 0-4)
    n_assets = 5
    with pytest.raises(ValueError, match="is not in"):
        validate_input_list(items, n_assets, assets_names=None, name="test_assets")


# Test with valid string inputs.
def test_string_inputs_valid():
    assets_names = np.array(["A", "B", "C", "D", "E"])
    items = ["A", "D"]
    n_assets = len(assets_names)
    result = validate_input_list(
        items, n_assets, assets_names=assets_names, name="test_assets"
    )
    # "A" corresponds to index 0, "D" corresponds to index 3.
    assert result == [0, 3]


# Test with strings when assets_names is None.
def test_string_inputs_no_assets_names():
    items = ["A", "B"]
    n_assets = 2
    with pytest.raises(ValueError, match="must input `X`"):
        validate_input_list(items, n_assets, assets_names=None, name="test_assets")


# Test with duplicate entries (order is preserved).
def test_duplicate_entries():
    assets_names = np.array(["X", "Y", "Z"])
    # Both integer and string (that converts to the same index) are provided.
    items = [1, "Y", 1, "Y"]
    n_assets = len(assets_names)
    with pytest.raises(ValueError, match="Duplicates found"):
        _ = validate_input_list(
            items, n_assets, assets_names=assets_names, name="test_assets"
        )


# Test with a mix of valid integers and valid strings.
def test_mixed_inputs():
    assets_names = np.array(["Asset1", "Asset2", "Asset3", "Asset4"])
    # "Asset3" corresponds to index 2 and integer 0 is valid.
    items = [0, "Asset3"]
    n_assets = len(assets_names)
    result = validate_input_list(
        items, n_assets, assets_names=assets_names, name="test_assets"
    )
    assert result == [0, 2]


def test_validate_input_list_raise():
    assets_names = np.array(["Asset1", "Asset2", "Asset3", "Asset4"])
    # "Asset3" corresponds to index 2 and integer 0 is valid.
    items = ["Asset3", "wrong name"]
    n_assets = len(assets_names)
    with pytest.raises(ValueError):
        _ = validate_input_list(
            items, n_assets, assets_names=assets_names, name="test_assets"
        )

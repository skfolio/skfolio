
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/1_mean_risk/plot_6_transaction_costs.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_1_mean_risk_plot_6_transaction_costs.py>`
        to download the full example code or to run this example in your browser via Binder

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_1_mean_risk_plot_6_transaction_costs.py:


=================
Transaction Costs
=================

This tutorial shows how to incorporate transaction costs (TC) into the
:class:`~skfolio.optimization.MeanRisk` optimization.

TC are fixed costs incurred when buying or selling an asset.

By using the `transaction_costs` parameter, you can add linear TC to the optimization
problem:

.. math:: total\_cost = \sum_{i=1}^{N} c_{i} \times |w_{i} - w\_prev_{i}|

with :math:`c_{i}` the TC of asset i, :math:`w_{i}` its weight and :math:`w\_prev_{i}`
its previous weight (defined in `previous_weights`).
The float :math:`total\_cost` is impacting the portfolio expected return in the
optimization:

.. math:: expected\_return = \mu^{T} \cdot w - total\_cost

with :math:`\mu` the vector af assets expected returns and :math:`w` the vector of
assets weights.

the `transaction_costs` parameter can be a float, a dictionary or an array-like of
shape `(n_assets, )`. If a float is provided, it is applied to each asset.
If a dictionary is provided, its (key/value) pair must be the (asset name/asset TC) and
the input `X` of the `fit` method must be a DataFrame with the assets names in columns.
The default is 0.0 (no transaction costs).

.. warning::

    According to the above formula, the periodicity of the transaction costs
    needs to be homogenous to the periodicity of :math:`\mu`. For example, if
    the input `X` is composed of **daily** returns, the `transaction_costs` need
    to be expressed as **daily** costs.

This means that you need to convert this fixed transaction costs into daily costs. To
achieve this, you need the notion of expected investment duration. This is crucial since
the optimization problem has no notion of investment duration.

For example, let's assume that asset A has an expected daily return of 0.01%
with a TC of 1% and asset B has an expected daily return of 0.005% with no TC.
Let's assume both assets have the same volatility and a correlation of 1.0.
If the investment duration is only one month, we should allocate all the weights to
asset B. However, if the investment duration is one year, we should allocate all the
weights to asset A.

Example:
    * Duration = 1 months (21 business days):
        * 1 month expected return A ≈ -0.8%
        * 1 month expected return B ≈ 0.1%
    * Duration = 1 year (252 business days):
        * 1 year expected return A ≈ 1.5%
        * 1 year expected return B ≈ 1.3%

So in order to take that duration into account, you should divide the fix TC by the
expected investment duration.

.. GENERATED FROM PYTHON SOURCE LINES 63-69

Data
====
We load the S&P 500 :ref:`dataset <datasets>` composed of the daily prices of 20
assets from the S&P 500 Index composition starting from 1990-01-02 up to 2022-12-28.
We select only 3 assets to make the example more readable, which are Apple (AAPL),
General Electric (GE) and JPMorgan (JPM):

.. GENERATED FROM PYTHON SOURCE LINES 69-84

.. code-block:: Python


    import numpy as np
    from plotly.io import show

    from skfolio import MultiPeriodPortfolio, Population, Portfolio
    from skfolio.datasets import load_sp500_dataset
    from skfolio.model_selection import WalkForward, cross_val_predict
    from skfolio.optimization import MeanRisk, ObjectiveFunction
    from skfolio.preprocessing import prices_to_returns

    prices = load_sp500_dataset()
    prices = prices[["AAPL", "GE", "JPM"]]

    X = prices_to_returns(prices)








.. GENERATED FROM PYTHON SOURCE LINES 85-89

Model
=====
In this tutorial, we will use the Maximum Mean-Variance Utility model with a risk
aversion of 1.0:

.. GENERATED FROM PYTHON SOURCE LINES 89-93

.. code-block:: Python

    model = MeanRisk(objective_function=ObjectiveFunction.MAXIMIZE_UTILITY)
    model.fit(X)
    model.weights_





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    array([6.17733231e-01, 3.78775169e-09, 3.82266765e-01])



.. GENERATED FROM PYTHON SOURCE LINES 94-102

Transaction Cost
================
Let's assume we have the below TC:
  * Apple: 1%
  * General Electric: 0.50%
  * JPMorgan: 0.20%

and an investment duration of one month (21 business days):

.. GENERATED FROM PYTHON SOURCE LINES 102-105

.. code-block:: Python

    transaction_costs = {"AAPL": 0.01 / 21, "GE": 0.005 / 21, "JPM": 0.002 / 21}
    # Same as transaction_costs = np.array([0.01, 0.005, 0.002]) / 21








.. GENERATED FROM PYTHON SOURCE LINES 106-107

First, we assume that there is no previous position:

.. GENERATED FROM PYTHON SOURCE LINES 107-114

.. code-block:: Python

    model_tc = MeanRisk(
        objective_function=ObjectiveFunction.MAXIMIZE_UTILITY,
        transaction_costs=transaction_costs,
    )
    model_tc.fit(X)
    model_tc.weights_





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    array([4.11868007e-01, 1.40979832e-07, 5.88131852e-01])



.. GENERATED FROM PYTHON SOURCE LINES 115-116

The higher TC of Apple induced a change of weights toward JPMorgan:

.. GENERATED FROM PYTHON SOURCE LINES 116-118

.. code-block:: Python

    model_tc.weights_ - model.weights_





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    array([-2.05865225e-01,  1.37192080e-07,  2.05865087e-01])



.. GENERATED FROM PYTHON SOURCE LINES 119-120

Now, let's assume that the previous position was equal-weighted:

.. GENERATED FROM PYTHON SOURCE LINES 120-128

.. code-block:: Python

    model_tc2 = MeanRisk(
        objective_function=ObjectiveFunction.MAXIMIZE_UTILITY,
        transaction_costs=transaction_costs,
        previous_weights=np.ones(3) / 3,
    )
    model_tc2.fit(X)
    model_tc2.weights_





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    array([0.33333336, 0.3333332 , 0.33333345])



.. GENERATED FROM PYTHON SOURCE LINES 129-131

Notice that the weight of General Electric becomes non-negligible due to the cost of
rebalancing the position:

.. GENERATED FROM PYTHON SOURCE LINES 131-133

.. code-block:: Python

    model_tc2.weights_ - model.weights_





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    array([-0.28439988,  0.3333332 , -0.04893332])



.. GENERATED FROM PYTHON SOURCE LINES 134-138

Multi-period portfolio
======================
Let's assume that we want to rebalance our portfolio every 60 days by re-fitting the
model on the latest 60 days. We test the impact of TC using Walk Forward Analysis:

.. GENERATED FROM PYTHON SOURCE LINES 138-143

.. code-block:: Python

    holding_period = 60
    fitting_period = 60
    cv = WalkForward(train_size=fitting_period, test_size=holding_period)









.. GENERATED FROM PYTHON SOURCE LINES 144-146

As explained above, we transform the fix TC into a daily cost by dividing the TC by
the expected investment duration:

.. GENERATED FROM PYTHON SOURCE LINES 146-148

.. code-block:: Python

    transaction_costs = np.array([0.01, 0.005, 0.002]) / holding_period








.. GENERATED FROM PYTHON SOURCE LINES 149-150

First, we train and test the model without TC:

.. GENERATED FROM PYTHON SOURCE LINES 150-155

.. code-block:: Python

    model = MeanRisk(objective_function=ObjectiveFunction.MAXIMIZE_UTILITY)
    # pred1 is a MultiPeriodPortfolio
    pred1 = cross_val_predict(model, X, cv=cv, n_jobs=-1)
    pred1.name = "pred1"








.. GENERATED FROM PYTHON SOURCE LINES 156-159

Then, we train the model without TC and test it with TC. The model trained without TC
is the same as above so we can retrieve the results and simply update the prediction
with the TC:

.. GENERATED FROM PYTHON SOURCE LINES 159-171

.. code-block:: Python

    pred2 = MultiPeriodPortfolio(name="pred2")
    previous_weights = None
    for portfolio in pred1:
        new_portfolio = Portfolio(
            X=portfolio.X,
            weights=portfolio.weights,
            previous_weights=previous_weights,
            transaction_costs=transaction_costs,
        )
        previous_weights = portfolio.weights
        pred2.append(new_portfolio)








.. GENERATED FROM PYTHON SOURCE LINES 172-175

Finally, we train and test the model with TC. Note that we cannot use the
`cross_val_predict` function anymore because it uses parallelization and cannot handle
the `previous_weights` dependency between folds:

.. GENERATED FROM PYTHON SOURCE LINES 175-188

.. code-block:: Python

    pred3 = MultiPeriodPortfolio(name="pred3")

    model.set_params(transaction_costs=transaction_costs)
    previous_weights = None
    for train, test in cv.split(X):
        X_train = X.take(train)
        X_test = X.take(test)
        model.set_params(previous_weights=previous_weights)
        model.fit(X_train)
        portfolio = model.predict(X_test)
        pred3.append(portfolio)
        previous_weights = model.weights_








.. GENERATED FROM PYTHON SOURCE LINES 189-191

We visualize the results by plotting the cumulative returns of the successive test
periods:

.. GENERATED FROM PYTHON SOURCE LINES 191-195

.. code-block:: Python

    population = Population([pred1, pred2, pred3])
    fig = population.plot_cumulative_returns()
    show(fig)




.. raw:: html
    :file: images/sphx_glr_plot_6_transaction_costs_001.html





.. GENERATED FROM PYTHON SOURCE LINES 196-200

|

If we exclude the unrealistic prediction without TC, we notice that the model
**fitted with TC** outperforms the model **fitted without TC**.


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 7.634 seconds)


.. _sphx_glr_download_auto_examples_1_mean_risk_plot_6_transaction_costs.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: binder-badge

      .. image:: images/binder_badge_logo.svg
        :target: https://mybinder.org/v2/gh/skfolio/skfolio/gh-pages?urlpath=lab/tree/notebooks/auto_examples/1_mean_risk/plot_6_transaction_costs.ipynb
        :alt: Launch binder
        :width: 150 px

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_6_transaction_costs.ipynb <plot_6_transaction_costs.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_6_transaction_costs.py <plot_6_transaction_costs.py>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
